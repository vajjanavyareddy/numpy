# -*- coding: utf-8 -*-
"""numpy.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-toYkeYZjl7IPrnho86mJqzKEMnq4vMG
"""

pip install numpy

import numpy as np

arr1 = np.array([2,3,4])
print(arr1)

arr2 = np.array([[2,3],[4,5]])
print(arr2)

arr3 = np.array([[[1,2],[3,4]],[[5,6],[7,8]]])
print(arr3)

print(arr1.ndim)
print(arr2.ndim)
print(arr3.ndim)

zeros = np.zeros((3,3))
print(zeros)

ones=np.ones((3,3))
print(ones)

random_arr = np.random.random((3,3))
print(random_arr)

eye = np.eye(3)
print(eye)

range_arr = np.arange(0,10,3)
print(range_arr)

arr = np.array([[1,2,3],[4,5,6]])
print("Shape: ",arr.shape)
print("SIze: ",arr.size)
print("Data Type: ",arr.dtype)
print("Number of dimensions: ",arr.ndim)

"""You are working as a Data Engineer for a smart agriculture startup that collects sensor data from multiple greenhouses.
Each greenhouse has sensors that record temperature (Â°C) readings at different times of the day.
You received the following data:
Your tasks are:
Create NumPy arrays
Create a 2D NumPy array named temp_data to represent the temperature readings from both greenhouses.
Print the array.
Check array properties
Print the shape, size, data type, and number of dimensions of temp_data.
Add a third greenhouse
The third greenhouse (GH3) records [21, 23, 22].
Create a new array updated_temp_data that includes all three greenhouses.
Generate supporting data
Create a zeros array (2Ã—3) called sensor_error_flags to represent whether there were any sensor errors (0 means no error).
Create an identity matrix of size 3Ã—3 named greenhouse_identity to uniquely identify each greenhouse.
Display all arrays
Print updated_temp_data, sensor_error_flags, and greenhouse_identity
"""

gh1 = [23,34,45]
gh2 = [98,34,78]
temp_data = np.array([gh1,gh2])
print("Temperature Data (2 Greenhouses):")
print(temp_data)

print("\nArray Properties:")
print("Shape:", temp_data.shape)
print("Size:", temp_data.size)
print("Data type:", temp_data.dtype)
print("Number of dimensions:", temp_data.ndim)

gh3 = [21,23,22]
updated_temp_data = np.vstack([temp_data,gh3])
print("\nUpdated Temperature Data (3 Greenhouses):")
print(updated_temp_data)

sensor_error_flags = np.zeros((2,3))
greenhouse_identity = np.identity(3)

print("updated_temp_data")
print(updated_temp_data)
print("\nSensor Error Flags (2x3):")
print(sensor_error_flags)
print("\nGreenhouse Identity Matrix (3x3):")
print(greenhouse_identity)

arr4 = np.array([[1,2,3],[4,5,6]])
print(arr4)

print(arr[0,2])
print(arr[1,-2])
print(arr[1,2])
print(arr[0,-2])

print(arr[:,1:])

"""Indexing and Slicing:
You are working as a Data Analyst at a fruit distribution company.
The company stores the number of fruit boxes shipped per day (for 1 week) in a 2D NumPy array where:
Each row represents a type of fruit.
Each column represents a day of the week (Monâ€“Sun).


Your Tasks
Create the 2D NumPy array
Create an array named shipments using the above data.
Access single elements (Indexing):
Get the number of Apples shipped on Wednesday.
Get the number of Oranges shipped on Sunday.
Access multiple elements (Slicing):
Extract all the weekday shipments (Monâ€“Fri) for all fruits.
Extract only the weekend shipments (Sat & Sun).
Extract the shipments of Apples from Wednesday to Saturday.
Bonus (Practice thinking):
Replace the Saturday shipment of Apples (currently 80) with 100 using indexing
"""

apples = [50,60,55,70,65,80,90]
Oranges = [40,45,50,60,55,70,75]
weekdays = ['Monday','Tuesday','Wednesday','Thursday','Friday','Saturday','Sunday']
shipments = np.array([apples,Oranges])
print(shipments)

apples_wednesday = shipments[0, 2]
print("Apples shipped on Wednesday:", apples_wednesday)


oranges_sunday = shipments[1, 6]
print("Oranges shipped on Sunday:", oranges_sunday)


weekday_shipments = shipments[:, 0:5]
print("\nWeekday Shipments (Mon-Fri):")
print(weekday_shipments)


weekend_shipments = shipments[:, 5:7]
print("\nWeekend Shipments (Sat & Sun):")
print(weekend_shipments)


apples_wed_to_sat = shipments[0, 2:6]
print("\nApples Shipments (Wed to Sat):")
print(apples_wed_to_sat)


shipments[0, 5] = 100
print("\nShipments after updating Saturday Apples:")
print(shipments)

a = np.array([1,2,3])
b = np.array([4,5,6])
print(a+b)
print(a-b)
print(a*b)
print(a*2)

mat1 = np.array([[4,5],[2,3]])
mat2 = np.array([[7,8],[9,2]])
res = np.dot(mat1,mat2)
print("Dot Product: \n",res)

x = np.array([1,2,3])
y = 3
print(x+y)

"""Universal Functions


Operate element-wise on arrays.
np.add(x, y)
np.subtract(x, y)
np.multiply(x, y)
np.divide(x, y)
np.power(x, y)
np.mod(x, y)
ðŸ”¹ 2. Exponential and Logarithmic ufuncs
(You already covered these)
np.exp(x)
np.log(x)
np.log10(x)
np.log2(x)
np.expm1(x)    # exp(x) - 1
ðŸ”¹ 3. Trigonometric ufuncs
np.sin(x)
np.cos(x)
np.tan(x)
np.arcsin(x)
np.arccos(x)
np.arctan(x)
np.degrees(x)
np.radians(x)
ðŸ”¹ 4. Rounding ufuncs
np.round(x)
np.floor(x)
np.ceil(x)
np.trunc(x)
ðŸ”¹ 5. Statistical ufuncs
(Operate along an axis or entire array)
np.min(x)
np.max(x)
np.mean(x)
np.std(x)
np.var(x)
np.sum(x)
np.prod(x)
ðŸ”¹ 6. Logical ufuncs
np.logical_and(x, y)
np.logical_or(x, y)
np.logical_not(x)
np.logical_xor(x, y)
ðŸ”¹ 7. Comparison ufuncs
(Return Boolean arrays)
np.greater(x, y)
np.less(x, y)
np.equal(x, y)
np.not_equal(x, y)
np.greater_equal(x, y)
np.less_equal(x, y)
ðŸ”¹ 8. Bitwise ufuncs
(Operate on integers)
np.bitwise_and(x, y)
np.bitwise_or(x, y)
np.bitwise_xor(x, y)
np.invert(x)
"""

arr = np.array([4,5,6])
print(np.exp(arr))
print(np.sqrt(arr))
print(np.log(arr))

x = np.array([23,56,-23,78])
print(np.min(x))
print(np.max(x))
print(np.mean(x))
print(np.std(x))
print(np.sum(x))
print(np.prod(x))

np.invert(x)

"""You are a data engineer at a renewable-energy company that runs 3 solar farms.
Each farm has 4 solar panels, and each panel reports hourly energy production (kWh) for 3 hours during a test window.

Given data (raw)
Create arrays from these values:
production â€” shape (3 farms Ã— 4 panels Ã— 3 hours) represented as a 2D array per farm (you can stack/create as shown in tasks).
Farm A panels (rows = panels, cols = hours):


Tasks
Create arrays
Create three 2D NumPy arrays farmA, farmB, farmC (each shape (4,3)).
Stack them into a single 3D array production_all of shape (3, 4, 3).
Array attributes
Print the .shape, .size, .dtype, and .ndim of production_all.
Per-farm totals (arithmetic & aggregation)
Use aggregation ufuncs to compute the total energy per farm (sum across panels & hours) â†’ total_per_farm (shape (3,)).
Compute mean, std, and var per farm.
Per-hour matrix multiplication idea (matrix op)
For a quick weighted estimate, create a hour_weights row vector of shape (3,) = [0.5, 1.0, 0.75] (weights for hour1, hour2, hour3).
Compute weighted_per_panel by performing a dot product between each farm's panel-row and hour_weights to get per-panel weighted energy. (Use np.dot / matrix multiplication appropriately.)
Broadcasting adjustments
The operator notices a fixed calibration offset of +0.5 kWh for all panels in Farm B. Use broadcasting to add this offset to Farm B data inside production_all (without recreating whole array manually).
Element-wise arithmetic (ufuncs: add/sub/mul/div/power/mod)
Compute a normalized version where you:
subtract the per-farm mean (use broadcasting),
divide by the per-farm std (broadcasting) â€” i.e., z-score normalize each farm's panel-hour readings.
Apply many ufuncs (use the ufuncs listed previously)
Apply the following element-wise operations (create variables for each) on the normalized data (or a copy) and show the resulting arrays (or summaries â€” shape/dtype/first row) where appropriate:
Exponential family: np.exp, np.expm1, np.log (note: handle non-positive inputs if needed), np.log10, np.log2.
Trigonometric: np.sin, np.cos, np.tan, np.arcsin, np.arccos, np.arctan, plus np.degrees, np.radians applied appropriately.
Rounding: np.round, np.floor, np.ceil, np.trunc.
Comparison & logical ufuncs: create a boolean mask high_output = production_all > 20 and apply np.logical_and, np.logical_or, np.logical_not, np.logical_xor combining masks (e.g., high_output and even_hours_mask). Also use comparison ufuncs like np.greater_equal, np.less.
Bitwise ufuncs (on integer arrays): create an integer array alerts = np.array([[1,0,1],[0,0,1],[1,1,0],[0,1,0]]) for each farm (shape match required) â€” then apply np.bitwise_and, np.bitwise_or, np.invert where sensible.
Arithmetic ufuncs again: np.add, np.subtract, np.multiply, np.divide, np.power, np.mod.
Aggregations over ufunc outputs: e.g., np.sum(np.exp(...)), np.mean(np.sin(...)).
Broadcast-based summary table
Use broadcasting to compute a (3,4) array panel_totals_per_farm = total per panel (sum across hours for each panel), and then compute a (3,) boolean needs_maintenance saying True if any panel in that farm has total < 40. Use np.min, np.max, np.any, np.all.
Final KPIs (aggregation)
Compute:
overall_total (sum of all farms),
peak_hour value (max across hours) and which farm & panel produced it (use np.argmax with careful unraveling),
average_per_panel across all farms.
"""

FarmA = np.array([[10,12,11],[9,11,10],[12,13,14],[8,7,9]])
FarmB = np.array([[20,19,21],[18,20,19],[22,23,21],[17,18,16]])
FarmC = np.array([[15,16,14],[14,13,15],[16,17,18],[12,11,13]])

production_all = np.stack([FarmA, FarmB, FarmC])


print("Shape of production_all:", production_all.shape)
print("Size of production_all:", production_all.size)
print("Data type of production_all:", production_all.dtype)
print("Number of dimensions of production_all:", production_all.ndim)

total_per_farm = np.sum(production_all, axis=(1, 2))
print("\nTotal energy per farm:")
print(total_per_farm)


mean_per_farm = np.mean(production_all, axis=(1, 2))
print("\nMean energy per farm:")
print(mean_per_farm)


std_per_farm = np.std(production_all, axis=(1, 2))
print("\nStandard deviation per farm:")
print(std_per_farm)


var_per_farm = np.var(production_all, axis=(1, 2))
print("\nVariance per farm:")
print(var_per_farm)

hour_weights = np.array([0.5, 1.0, 0.75])
print("\nHour Weights:", hour_weights)


weighted_per_panel = np.dot(production_all, hour_weights)
print("\nWeighted energy per panel:")
print(weighted_per_panel)

production_all = production_all.astype(np.float64)

production_all[1, :, :] += 0.5

print("\nProduction data after adding offset to Farm B:")
print(production_all)

mean_per_farm = np.mean(production_all, axis=(1, 2), keepdims=True)
std_per_farm = np.std(production_all, axis=(1, 2), keepdims=True)


normalized_production = (production_all - mean_per_farm) / std_per_farm

print("\nNormalized Production Data (Z-score normalized per farm):")
print(normalized_production)

# Apply Exponential ufuncs
exp_normalized = np.exp(normalized_production)
expm1_normalized = np.expm1(normalized_production)

log_production = np.log(production_all)
log10_production = np.log10(production_all)
log2_production = np.log2(production_all)

print("\nExponential ufuncs on normalized data (exp, expm1):")
print("exp_normalized shape:", exp_normalized.shape)
print("expm1_normalized shape:", expm1_normalized.shape)

print("\nLogarithmic ufuncs on original data (log, log10, log2):")
print("log_production shape:", log_production.shape)
print("log10_production shape:", log10_production.shape)
print("log2_production shape:", log2_production.shape)


sin_normalized = np.sin(normalized_production)
cos_normalized = np.cos(normalized_production)
tan_normalized = np.tan(normalized_production)

print("\nTrigonometric ufuncs on normalized data (sin, cos, tan):")
print("sin_normalized shape:\n", sin_normalized)
print("cos_normalized shape:\n", cos_normalized)
print("tan_normalized shape:\n", tan_normalized)
# print("arcsin:\n",np.arcsin(normalized_production))
# print("arccos:\n",np.arccos(normalized_production))
print("arctan:\n",np.arctan(normalized_production))


round_normalized = np.round(normalized_production)
floor_normalized = np.floor(normalized_production)
ceil_normalized = np.ceil(normalized_production)
trunc_normalized = np.trunc(normalized_production)

print("\nRounding ufuncs on normalized data (round, floor, ceil, trunc):")
print("round_normalized shape:", round_normalized.shape)
print("floor_normalized shape:", floor_normalized.shape)
print("ceil_normalized shape:", ceil_normalized.shape)
print("trunc_normalized shape:", trunc_normalized.shape)

high_output = production_all > 20
print("\nBoolean mask for high output (> 20):")
print(high_output)


hours = np.arange(production_all.shape[2])
even_hours_mask = (hours % 2 == 0)

even_hours_mask = even_hours_mask.reshape(1, 1, -1)
print("\nBoolean mask for even hours:")
print(even_hours_mask)



logical_and_mask = np.logical_and(high_output, even_hours_mask)
print("\nLogical AND mask (high_output and even_hours):")
print(logical_and_mask)

logical_or_mask = np.logical_or(high_output, even_hours_mask)
print("\nLogical OR mask (high_output or even_hours):")
print(logical_or_mask)

logical_not_high_output = np.logical_not(high_output)
print("\nLogical NOT mask (not high_output):")
print(logical_not_high_output)

logical_xor_mask = np.logical_xor(high_output, even_hours_mask)
print("\nLogical XOR mask (high_output xor even_hours):")
print(logical_xor_mask)


greater_equal_mask = np.greater_equal(production_all, 15)
print("\nGreater Equal mask (production_all >= 15):")
print(greater_equal_mask)

less_mask = np.less(production_all, 10)
print("\nLess mask (production_all < 10):")
print(less_mask)

alerts = np.array([[[1, 0, 1], [0, 0, 1], [1, 1, 0], [0, 1, 0]],
                   [[0, 1, 0], [1, 0, 1], [0, 0, 1], [1, 1, 0]],
                   [[1, 1, 0], [0, 1, 0], [1, 0, 1], [0, 0, 1]]])
print("\nAlerts data (integer array):")
print(alerts)


bitwise_and_result = np.bitwise_and(alerts, alerts)
print("\nBitwise AND result (alerts & alerts):")
print(bitwise_and_result)

bitwise_or_result = np.bitwise_or(alerts, alerts)
print("\nBitwise OR result (alerts | alerts):")
print(bitwise_or_result)

bitwise_xor_result = np.bitwise_xor(alerts, alerts)
print("\nBitwise XOR result (alerts ^ alerts):")
print(bitwise_xor_result)


invert_alerts = np.invert(alerts.astype(np.uint8))
print("\nBitwise NOT result (~alerts):")
print(invert_alerts)

print("\nAggregations over ufunc outputs:")


sum_exp_normalized = np.sum(np.exp(normalized_production))
print("Sum of exp(normalized_production):", sum_exp_normalized)


mean_sin_normalized = np.mean(np.sin(normalized_production))
print("Mean of sin(normalized_production):", mean_sin_normalized)


max_log10_production = np.max(np.log10(production_all))
print("Max of log10(production_all):", max_log10_production)

# Arithmetic ufuncs again

arr1 = np.array([[1, 2], [3, 4]])
arr2 = np.array([[5, 6], [7, 8]])
scalar = 2

print("\nArithmetic ufuncs:")

# Add
add_result = np.add(arr1, arr2)
print("np.add(arr1, arr2):\n", add_result)

# Subtract
subtract_result = np.subtract(arr1, arr2)
print("np.subtract(arr1, arr2):\n", subtract_result)

# Multiply
multiply_result = np.multiply(arr1, arr2)
print("np.multiply(arr1, arr2):\n", multiply_result)

# Divide

divide_result = np.divide(arr1, arr2)
print("np.divide(arr1, arr2):\n", divide_result)

# Power
power_result = np.power(arr1, scalar)
print("np.power(arr1, scalar):\n", power_result)

# Modulo
arr3 = np.array([[10, 20], [30, 40]])
arr4 = np.array([[3, 7], [9, 11]])
mod_result = np.mod(arr3, arr4)
print("np.mod(arr3, arr4):\n", mod_result)

panel_totals_per_farm = np.sum(production_all, axis=2)
print("\nTotal energy per panel per farm:")
print(panel_totals_per_farm)

maintenance_threshold = 40


needs_maintenance = np.any(panel_totals_per_farm < maintenance_threshold, axis=1)
print("\nFarms needing maintenance (True if any panel total < {}):".format(maintenance_threshold))
print(needs_maintenance)


min_per_panel_per_farm = np.min(production_all, axis=2)
print("\nMinimum energy per panel per farm:")
print(min_per_panel_per_farm)

max_per_panel_per_farm = np.max(production_all, axis=2)
print("\nMaximum energy per panel per farm:")
print(max_per_panel_per_farm)

# Final KPIs (aggregation)


overall_total = np.sum(production_all)
print("\nOverall total energy production:", overall_total)


peak_hour_value = np.max(production_all)
print("\nPeak hour energy value:", peak_hour_value)


flattened_index = np.argmax(production_all)

peak_location = np.unravel_index(flattened_index, production_all.shape)
print("Location of peak hour value (Farm, Panel, Hour):", peak_location)


average_per_panel_overall = np.mean(np.sum(production_all, axis=2))
print("\nAverage energy per panel across all farms:", average_per_panel_overall)

arr= np.array([1,2,3,4,5,6])
print(arr.reshape(3,2))

x= np.array([0,9,8])
y = np.array([6,5,4])
print(np.vstack((x,y)))
print(np.hstack((x,y)))

z= np.array([1,2,3,4,5,6])
print(np.array_split(z,3))

z = np.array([1,2,3,4,5,4,6,7,8,7,8,8,8,0])
print(np.array_split(z,3))

z= np.array([1,2,3,4,5,6])
print(arr[arr%2==0])

z= np.array([1,2,3,4,5,6])
i = [0,1,3]
print(arr[i])

z= np.array([1,2,3,4,5,6])
z[0]=10
print(z)

z= np.array([1,2,3,4,5,6])
view = z.view()
view[0]=10
print(z)
print(view)

z= np.array([1,2,3,4,5,6])
copy = z.copy()
copy[0]=10
print(z)
print(copy)

ar = np.array([1,2,3])
np.save("myarray",ar)
loaded= np.load("myarray.npy")
print(loaded)

"""TasksArray Creation
Create a 1D array of numbers from 10 to 50.
Create a 3x3 array of random numbers between 0 and 1.
Array Attributes
Find the shape, size, and data type of the array you created in the previous task.
Basic Operations
Add 5 to every element of a 1D array.
Multiply two 2D arrays element-wise.
Indexing and Slicing
Create a 5x5 array of integers from 1 to 25. Extract:
The first row.
The last column.
A subarray of the first three rows and first two columns.
Aggregation
Create a 10-element array of random integers between 10 and 100. Find:
The maximum value.
The minimum value.
The mean and standard deviation.
Reshaping
Convert a 1D array of numbers from 1 to 12 into a 3x4 matrix.
Broadcasting
Create a 3x3 matrix of ones. Add a 1D array [1, 2, 3] to each row.
Filtering
Create a 1D array of random integers between 1 and 50. Extract all elements that are divisible by 5.
Matrix Multiplication
Create two 2x2 matrices and perform matrix multiplication.
Advanced Indexing
Given a 4x4 array, use fancy indexing to extract the diagonal elements.
"""

num = np.arange(10,51)

ran = np.random.random((3,3))
print(num)
print(ran)

print("Shape: ",num.shape)
print("Size: ",num.size)
print("DType: ",num.dtype)

print("Shape: ",ran.shape)
print("Size: ",ran.size)
print("DType: ",ran.dtype)

add5 = np.add(num,5)
print(add5)

array1 = np.array([[1, 2], [3, 4]])
array2 = np.array([[5, 6], [7, 8]])

print("Array 1:\n", array1)
print("\nArray 2:\n", array2)


element_wise_multiply = array1 * array2


print("\nElement-wise multiplication result:\n", element_wise_multiply)

array_5x5 = np.arange(1, 26).reshape(5, 5)
print("Original 5x5 array:\n", array_5x5)


first_row = array_5x5[0, :]
print("\nFirst row:", first_row)



last_column = array_5x5[:, -1]
print("\nLast column:", last_column)


subarray = array_5x5[0:3, 0:2]
print("\nSubarray (first 3 rows, first 2 columns):\n", subarray)

random_integers = np.random.randint(10, 101, 10)
print("Random integer array:", random_integers)


max_value = np.max(random_integers)
print("\nMaximum value:", max_value)


min_value = np.min(random_integers)
print("Minimum value:", min_value)


mean_value = np.mean(random_integers)
print("Mean:", mean_value)


std_deviation = np.std(random_integers)
print("Standard deviation:", std_deviation)

arr1D = np.arange(1,13).reshape(3,4)
print(arr1D)

ones_matrix = np.ones((3, 3))
print("Original 3x3 matrix of ones:\n", ones_matrix)


array_1d = np.array([1, 2, 3])
print("\n1D array to add:\n", array_1d)


broadcasted_addition = ones_matrix + array_1d
print("\nResult after broadcasting addition:\n", broadcasted_addition)

random_int = np.random.randint(1,51)
print(random_int)

random_integers = np.random.randint(1, 51, 10)
print("Original random integer array:", random_integers)



filtered_elements = random_integers[random_integers % 5 == 0]
print("\nElements divisible by 5:", filtered_elements)

mat1 = np.array([[1, 2], [3, 4]])
mat2 = np.array([[5, 6], [7, 8]])

print("Matrix 1:\n", mat1)
print("\nMatrix 2:\n", mat2)

res = np.dot(mat1, mat2)


print("\nMatrix multiplication result:\n", res)

array_4x4 = np.arange(1, 17).reshape(4, 4)
print("Original 4x4 array:\n", array_4x4)


diagonal_indices = np.arange(4)
diagonal_elements = array_4x4[diagonal_indices, diagonal_indices]

print("\nDiagonal elements using fancy indexing:", diagonal_elements)


diag = np.diag(array_4x4)
print("Diagonal elements using np.diag():", diag)

